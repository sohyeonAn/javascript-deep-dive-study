## 원시 값과 객체의 비교
### 원시 값
- 원시 값을 변수에 할당하면 변수에는 **실제 값**이 저장.
#### 변경 불가능한 값
- 한번 생성된 원시 값은 **읽기 전용**. 변경 불가.
  - 원시 값 자체는 변경 할 수 없지만 변수 값은 가능.
  - 상수는 변수 값을 변경할 수 없음.
- 변수에 새로운 원시 값을 재할당하면?
  - 새로운 메모리 공간을 확보하고 재할당할 원시 값을 저장.
  - 변수는 새롭게 재할당한 원시 값을 가리킴. (변수가 참조하는 메모리 주소가 바뀜.)
  - 재할당 이전 원시 값을 가리키는 변수가 없어서 변경 불가능해 짐.

```js
// const 키워드를 사용해 선언한 변수는 재할당 금지.
const o = {};

// 변수에 할당한 원시 값(상수)는 변경할 수 없다.
// 하지만 변수에 할당한 객체는 변경할 수 있다.
o.a = 1;
console.log(o); // {a: 1}
```
#### 문자열과 불변성
- 문자열(2바이트), 숫자(8바이트) 이외의 원시 타입 크기는 브라우저 제조사 구현에 따라 다를 수 있음.
- 문자열은 몇 개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정.
```js
var str = 'string';

// 문자열은 원시 값이므로 변경할 수 없다.
str[0] = 'S';
console.log(str); // 'string'

// 새로운 문자열을 재할당하는 것은 가능하다.
// 기존 문자열의 변경이 아니라 새로운 문자열을 할당한다.
str = 'String';
console.log(str); // 'String'
```
#### 값에 의한 전달
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달.
  - 사실 값을 전달하는 게 아니라 **메모리 주소를 전달**.
  - 전달된 메모리 주소를 통해 값을 참조하므로 이렇게 표현. 
  - 새로운 값을 생성해서 메모리 주소를 전달한다면, 할당 시점에 두 변수가 기억하는 메모리 주소가 다름.
  - 복사할 변수값의 메모리 주소를 그대로 전달한다면, 할당 시점에 두 변수가 같은 메모리 주소를 가리킴.
  - 어쨌든 '재할당 이후'에 두 변수는 '서로 다른 메모리 공간'에 저장.
```js
var score = 80;
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

// score변수와 copy변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 copy 변수 값에는 어떠한 영향도 주지 않는다.
score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

<br>

### 객체

#### 변경 가능한 값
- 객체를 변수에 할당하면 변수에는 **참조 값**이 저장.
  - 참조 값: 생성된 객체가 저장된 메모리 공간의 주소.
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경 가능.
  - 재할당이 아니므로 참조 값은 변경되지 않음.
```js
var person = {
  name: 'Kim'
};

// 프로퍼티 값 갱신
person.name = 'An';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: 'An', address: 'Seoul'}
```
- 프로퍼티 개수와 프로퍼티의 값에 제약이 없어 확보해야할 메모리 공간의 크기를 정해 둘 수 없음.
- 따라서 원시타입처럼 재할당할 때 새로운 공간을 확보하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되었음.
- 부작용: 여러 개의 식별자가 하나의 객체를 공유할 수 있다. (참조에 의한 전달)


#### 참조에 의한 전달
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값**이 복사되어 전달됨.
```js
var pseron = {
  name: 'An'
}

var copy = person;
```
- 원본 person과 사본 copy는 다른 메모리 주소를 가지지만 동일한 참조 값을 가진다. (하나의 객체를 공유)
- 어느 한쪽에서 객체를 변경하면 서로 영향을 준다.
```js
var pseron = {
  name: 'An'
}

var copy = person;

console.log(copy === person); // true

copy.name = 'Lee';
person.address = 'Seoul';

console.log(person); // {name: 'Lee', address: 'Seoul'}
console.log(copy); // {name: 'Lee', address: 'Seoul'}
```
```js
var person1 = {
  name: 'An';
}

var person2 = {
  name: 'An';
}

console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
```