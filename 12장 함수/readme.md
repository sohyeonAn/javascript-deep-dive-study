## 함수
### 함수란?
- 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
- 함수는 **객체** 타입의 값이다. 
  - 일반 객체와 차이점:
  - 일반 객체는 호출할 수 없지만 함수는 호출 가능하다.
  - 함수 객체만의 고유한 프로퍼티를 갖는다.
- 함수를 실행하려면 **인수를 매개변수를 통해 함수에 전달**하면서 실행을 지시해야 한다. (=함수 호출)
- 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행결과를 반환한다.
- 인수: 입력
- 매개변수: 함수 내부로 입력을 전달받는 변수
- 반환값: 출력
```js
// 함수 정의하는 방법 (함수 선언문)
function add(x, y) {
  return x + y;
}

var result = add(2, 5); // 인수 전달을 통한 함수 실행 지시
console.log(result); // 7
```

<br>

### 함수를 사용하는 이유
- 같은 코드를 중복해서 여러 번 작성 하지 않아도 되므로 중복을 억제할 수 있고 몇 번이든 호출할 수 있으므로 재사용성이 높아진다.  --> **코드의 재사용**, **유지보수의 편의성**, **신뢰상승**
- 자신의 역할을 설명하는 적절한 함수 이름 --> **코드의 가독성**

<br>

### 함수 리터럴
- `function`키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.
- 함수 리터럴로 함수를 생성할 수 있다. 
- **리터럴**: 사람이 이해할 수 있는 문자또는 기호를 사용해 **값을 생성**하기 위한 표기법.
```js
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
- 함수 이름
  - 함수 몸체에서만 참조할 수 있다.
  - 함수 이름은 생략 가능하다.(=anonymous function)
- 매개변수 목록
  - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.
  - 함수를 호출할 때 지정한 인수가 **순서대로** 할당된다.
- 함수 몸체
  - 함수가 호출되었을 때 일괄적으로 실행될 문들을 정의한다.
  - 함수 호출에 의해 실행된다.

<br>

### 함수 정의
- 함수를 호출하기 전에 인수를 전달받을 매개변수와 실행할 문들, 반환값을 지정하는 것.
#### 함수를 지정하는 방법
##### 1. 함수 선언문
- 함수 리터럴과 형태가 동일하지만 **함수 이름을 생략할 수 없다.**
- 표현식이 아닌 문이다. (= 값으로 할당할 수 없다.)
```js
function (x, y) {
  return x + y;
} // SyntaxError: 이름을 생략할 수 없다.

// 올바른 함수 선언문
function add(x, y) {
  return x + y;
}
```
```js
// 함수 선언문은 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
}
```
👁‍🗨❗ **함수 선언문이 변수에 할당되는 것처럼 보이는 이유**
  - 자바스크립트 엔진은 **기명 함수**가 피연산자로 사용되지 않는 경우는 함수 선언문으로 해석하고, 변수에 할당하거나 피연산자로 사용하는 경우는 함수 표현식으로 해석한다. (즉, 위의 `function add(){...}`는 함수 표현식으로 해석된 것.)
```js
function foo() { console.log('foo'); }
foo(); // foo

// 괄호로 묶이는 피연산자는 값으로 평가될 수 있는 표현식이어야한다.
// 때문에 아래는 함수 표현식으로 해석 된다.
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar가 정의되지 않았다.
```
👁‍🗨❗ **`foo()`는 호출할 수 있지만 `bar()`를 호출할 수 없었던 이유**
  - 자바스크립트 엔진은 **함수 선언문**을 해석할 때, 함수 객체를 가리키는 함수 이름과 동일한 이름을 가진 식별자를 생성하고 거기에 함수 객체를 할당한다.
  - 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
  - 따라서, **함수 선언문**으로 해석된 `foo()`는 자바스크립트엔진에 의해 함수 객체를 가리키는 식별자가 생성되었지만 **함수 표현식**으로 해석된 `bar()`는 함수 객체를 가리키는 식별자가 생성되지 않아 호출할 수 없었다.

##### 2. 함수 표현식
- 자바스크립트의 함수는 일급 객체이므로 변수에 할당할 수 있다.
- 일급객체 ❔ 값의 성질을 갖는 객체.
- 변수에 값으로 할당된 함수 리터럴을 함수 표현식이라 한다.
- 함수 표현식은 함수 이름을 생략할 수 있다. (생략하는 게 더 일반적.)
- 함수 이름이 아니라 함수 객체를 가리키는 식별자로 호출해야 한다.
```js
var add = function foo(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7
console.log(foo(2, 5)); // ReferenceError
```
##### 3. Function 생성자 함수
- `Function` 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하고 `new` 연산자와 함께 호출한다.
- 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하므로 권장되지 않는다.
```js
var add = new Function('x', 'y', 'return x + y');
console.log(add(2, 5)); // 7
```
##### 4. 화살표 함수
- ES6에서 도입됐다.
- `function`키워드 대신 `=>` 사용한다.
- 항상 익명함수로 정의한다.
```js
const add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```
- 화살표함수는 기존 함수보다 표현만 간략한 것이 아니라 내부 동작도 간략화 됐다. (자세한 내용은 26장에서...)

#### 함수 생성 시점과 함수 호이스팅
- **함수 선언문**으로 정의한 함수는 **런타임 이전**에 함수 객체와 함수 이름과 동일한 이름의 식별자가 생성된다. (=호이스팅)
```js
// 함수 참조
console.dir(add); // f add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub는 function이 아니다.

// 함수 선언문
function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```
- **함수 표현식**은 변수 선언문과 변수 할당문을 한번에 축약한 표현과 동일하게 동작한다.
- 변수 선언은 런타임 이전에 실행되어 `undefined`로 초기화 되지만 변수 할당문의 값은 **실행되는 시점에 평가**되어 함수 객체가 된다. 
- 즉, 함수 표현식으로 함수를 정의 하면 **함수 호이스팅이 아니라 변수 호이스팅이 발생**한다.
- 따라서 **함수 표현식**으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.

### 함수호출
#### 매개변수와 인수
- 함수를 실행하기 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, **매개 변수**를 통해 **인수**를 전달한다.
- **인수**는 값으로 평가될 수 있는 표현식이어야 한다.
- 인수는 함수를 호출할 때 지정하며, 개수와 타입에 제한이 없다.
- 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다.
  - 함수 몸체에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 `undefined`로 초기화된 이후에 인수가 순서대로 할당된다.
- 매개변수는 함수 몸체 내부에서만 참조할 수 있다.
```js
function add(x, y) {
  console.log(x, y); // 2 5
  return x + y;
}

add(2, 5);

// x, y는 함수 몸체 내부에서만 참조가능.
console.log(x, y); // ReferenceError: x가 정의되지 않음.
```
- 매개변수의 개수와 인수의 개수가 일치하지 않아도 된다.
- 인수가 부족해서 할당되지 못한 매개변수는 `undefined`다.
- 인수가 매개변수보다 더 많은 경우 초과된 인수는 무시된다.
  - 버려지는 건 아니고 `arguments` 객체의 프로퍼티로 보관된다.(자세한 내용은 18장...)
```js
function add(x, y){ // x === 2, y === undefined
  returh x + y; 
}

console.log(add(2)); // NaN
```
#### 인수 확인
- 자바스크립트의 함수는 어떤 타입의 인수를 전달해야 하는지, 어떤 타입의 값을 반환하는지 명확하지 않기 때문에 사전 확인을 할 필요가 있다. (이래서 TypeScript를 쓰는 것..!)
```js
function add(x, y){
  if (typeof x !== 'number' || typeof y !== 'number'){
    throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
  }

  return x + y;
}

console.log(add(2)); // TypeError: 인수는 모두 숫자 값이어야 합니다.
console.log(add('a', 'b')); // TypeError: 인수는 모두 ...
```
- ES6부터 매개변수에 기본값을 사용할 수 있다.
  - 매개변수에 인수를 전달하지 않았을 경우와 `undefined`를 전달한 경우에 유효하다.
```js
// 기본값을 사용하지 않을 경우
// function add(a, b, c){
//   a = a || 0;
//   b = b || 0;
//   c = c || 0;
//   return a + b + c;
// }

// 기본값을 사용한 경우
function add(a = 0, b = 0, c = 0){
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```
#### 매개변수의 최대 개수
- 최대 개수에 대한 명시적 제한은 없다.
- 매개변수가 많아지면 사용법을 이해하기 어렵고 함수가 여러 가지 일을 한다는 증거이다.
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만드는 것이 좋으므로 매개변수는 적을 수록 좋다.

#### 반환문
- `return`키워드와 표현식으로 이뤄진다.
- 실행 결과를 함수 외부로 반환한다.
- 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
- 반환값을 지정하지 않으면 `undefined`가 반환된다.
- 반환문이 생략되면 암묵적으로 `undefined`가 반환된다.
- 함수 몸체 내부에서만 사용할 수 있다.
```js
function multiply(x, y) {
  return x * y; // 반환문
  // 반환문 이후에 다른 문은 실행되지 않고 무시된다.
  console.log('실행되지 않는다.');
}

console.log(multiply(2, 5)); // 10

function foo () {
  return ;
}

console.log(foo()); // undefined

function bar () { }
console.log(bar()); // undefined

function add(x, y) {
  return // return키워드와 반환값사이에 줄바꿈이 있으면 세미콜론이 자동 삽입되어 이후 문이 무시된다.
  x + y;
}
console.log(add(1, 2)); // undefined
```

<br>

### 참조에 의한 전달과 외부 상태의 변경
- 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.
```js
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: 'Lee'}

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: 'Kim'}
```
- 함수 내부에서 원본 객체를 훼손하는 것을 막기 위해 원본 객체를 완전히 복제 하는 **방어적 복사(깊은 복사)** 를 할 수 있다.

### 다양한 함수의 형태
#### 즉시 실행 함수
- 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다.
- 단 한번만 호출되며 다시 호출할 수 없다.
- 익명 함수를 사용하는 것이 일반적이다.
- 즉시 실행 함수는 반드시 그룹 연산자 `(...)`로 감싸야 한다.
  - 함수 리터럴을 평가해서 함수 객체를 생성하기 위함.
```js
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());

// 기명 즉시 실행 함수
(function foo() {
  var a = 3;
  var b = 4;
  return a * b;
}());

foo(); // 그룹 연산자 (...) 내의 기명함수는 함수 리터럴로 평가되기 떄문에 함수 몸체에서만 참조할 수 있다.
```
```js
function () {

}(); // SyntaxError: 함수 선언문은 함수 이름이 필요함.
```
👁‍🗨❗ 왜 오류가 날까?
- 함수 선언문은 이름을 생략할 수 없다.
```js
function foo () {

}(); // SyntaxError: Unexpected token ')'
// 
```
👁‍🗨❗ 왜 오류가 날까?
- 자바스크립트 엔진이 암묵적으로 함수 선언문이 끝나는 위치에 세미콜론(;)을 붙이기 때문이다. 
- 즉, 자동으로 `function foo () {};();` 으로 변경하기 때문에 뒤의 `()`는 그룹 연산자로 해석되고 피연산자가 없어 에러가 난다.

#### 재귀 함수
- 함수가 자기 자신을 호출하는 것.
```js
function countdown(n) {
  for(var i = n; i >= 10; i--) console.log(i);
}
countdown(10);


// 재귀함수로 표현
function countdown(n) {
  if (n < 10) return;
  console.log(n);
  conutdown(n - 1); // 재귀호출
}
countdown(10);
```
```js
// 재귀 함수를 이용한 팩토리얼
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

console.log(factorial(0)); // 0! = 1
console.log(factorial(1)); // 1! = 1
console.log(factorial(2)); // 2! = 2 * 1 = 2
console.log(factorial(3)); // 3! = 3 * 2 * 1 = 6
```
- 재귀 함수 내에서 재귀 호출을 멈추는 **탈출 조건**을 반드시 만들어야 한다. 위의 예시에서 **인수가 1 이하 일 때** 재귀 호출을 멈춘다.
  - 탈출 조건이 없으면 함수가 무한 호출되어 **스택 오버플로** 에러가 발생한다.

#### 중첩 함수
- 함수 내부에 정의된 함수.
- 중첩 함수를 포함하는 함수는 외부 함수라고 부른다.
- ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다. ( if문이나 for문 안에서도 가능 )
```js
function outer() {
  var x = 1;

  function inner() {
    var y = 2;
    console.log(x + y);
  }

  inner();
}

outer();
```

#### 콜백 함수
```js
// n만큼 어떤 일을 반복한다.
function repeat(n) {
  for (var i = 0; i < n; i++) console.log(i);
}

repeat(5); // 0 1 2 3 4
```
- repeat 함수는 console.log(i)에 강하게 의존하고 있어 다른 일을 할 수 없다.
- 만약 reqpeat 함수 반복문 내부에서 다른 일을 하고 싶다면 함수를 새롭게 정의해야 한다.

```js
function repeat1(n) {
  for (var i = 0; i < n; i++) console.log(i);
}
repeat1(5); // 0 1 2 3 4

function repeat2(n) {
  for (var i = 0; i < n; i++) {
    if (i % 2) console.log(i);
  }
}

repeat2(5); // 1 3
```
- 함수의 변하지 않는 **공통 로직은 미리 정의**해 두고, 경우에 따라 변경되는 로직은 추상화해 함수 외부에서 함수 내부로 전달하면 함수 내부의 로직에 강력히 의존하지 않고 유연한 구조를 갖을 수 있다.
```js
// 외부에서 전달받은 f를 n만큼 반복 호출한다.
function repeaet(n, f) {
   for (var i = 0; i < n; i++) f(i);
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

repeat(5, logOdds); // 1 3
```
- 이처럼 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수**라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수**라고 한다.
- 콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.
```js
repeat(5, function (i) {
  if (i % 2) console.log(i);
}); // 1 3
```
- 위와 같은 식으로 콜백 함수를 곧바로 고차 함수에 전달하면 고차 함수가 호출 될 때마다 새로운 함수 객체를 생성한다.
- 배열을 다룰 때 배열 고차 함수는 매우 중요하다. (자세한 내용은 27장...)
#### 순수 함수와 비순수 함수
- 순수 함수: 어떤 외부 상태에 의존하지 않고 변경하지도 않는, 부수 효과가 없는 함수.
- 비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수.
```js
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환하다.
function increase(n) {
  return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2

// 비순수 함수
function increase2() {
  return ++count; // 외부 상태를 직접 참조
}

// 외부 상태(count)를 변경하므로 상태 변화 추적이 어렵다.
increase2();
console.log(count); // 3
increase2();
console.log(count); //4
```
